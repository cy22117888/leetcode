31、下一个排序
===
实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。<br>
如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。<br>
必须原地修改，只允许使用额外常数空间。<br>

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br>
```
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
```

``
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/next-permutation
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
``

```
public void nextPermutation(int[] nums) {
        
        //定义换位的中间变量
        int change = 0;

        //存在下一个更大的排序
        for (int i = nums.length - 1; i > 0; --i) {
            //若前一位元素small大于当前位元素big时，
            if (nums[i] > nums[i-1]) {
                //倒序遍历到当前位，找出第一个比small大的元素bigger，交换位置
                for (int j = nums.length - 1; j >= i; --j) {
                    if (nums[i-1] < nums[j]) {
                        change = nums[j];
                        nums[j] = nums[i-1];
                        nums[i-1] = change;
                        break;
                    }
                }
                //将数组的当前位到最后位进行升序排列
                Arrays.sort(nums, i, nums.length);
                return;
            }
        }
        //不存在下一个更大的排序（入参为降序排列）
        for (int i = 0; i < nums.length / 2; ++i) {
            change = nums[nums.length - 1 - i];
            nums[nums.length - 1 - i] = nums[i];
            nums[i] = change; 
        }

    }
```
